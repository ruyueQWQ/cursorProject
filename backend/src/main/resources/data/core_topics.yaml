- title: 分治策略
  category: 算法思想
  overview: 通过将问题拆分为子问题并递归求解，再合并结果以得到整体解。
  keywords:
    - 分治
    - 递归
    - 主定理
  difficultyLevel: 2
  algorithms:
    - name: 归并排序
      coreIdea: 将数组一分为二，递归排序，再在合并阶段保持有序。
      steps: |
        1. 将数组拆成两个子数组；
        2. 分别递归排序子数组；
        3. 双指针线性合并。
      complexity: 时间复杂度 O(n log n)，空间复杂度 O(n)。
      codeSnippet: |
        public void mergeSort(int[] arr, int left, int right) {
            if (left >= right) return;
            int mid = (left + right) >> 1;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
      visualizationHint: 使用分治树展示拆分和合并。
      mermaidCode: |
        graph TD
          A[8, 4, 5, 7, 1, 3, 6, 2] -->|Split| B[8, 4, 5, 7]
          A -->|Split| C[1, 3, 6, 2]
          B -->|Split| D[8, 4]
          B -->|Split| E[5, 7]
          C -->|Sp lit| F[1, 3]
          C -->|Split| G[6, 2]
          D -->|Split| H[8]
          D -->|Split| I[4]
          H -->|Merge| J[4, 8]
          I -->|Merge| J
          E -->|Merge| K[5, 7]
          F -->|Merge| L[1, 3]
          G -->|Merge| M[2, 6]
          J -->|Merge| N[4, 5, 7, 8]
          K -->|Merge| N
          L -->|Merge| O[1, 2, 3, 6]
          M -->|Merge| O
          N -->|Merge| P[1, 2, 3, 4, 5, 6, 7, 8]
          style P fill:#f9f,stroke:#333,stroke-width:4px
    - name: 最近点对
      coreIdea: 先按坐标排序，按中线分成两部分，递归求解，再在跨区带内扫描。
      steps: |
        1. 按 x 轴排序；
        2. 递归求解左右最小距离；
        3. 在带宽 2d 条带中检查跨区点对。
      complexity: 平均与最坏时间复杂度皆为 O(n log n)。
      visualizationHint: 展示点集分割和中间条带的检查范围。
      mermaidCode: |
        graph TD
          Start["按 X 轴排序点集"] --> Split{"点数 <= 3?"}
          Split -- 是 --> Base[暴力求解]
          Split -- 否 --> Divide["中线分割: Left, Right"]
          Divide --> RecL["递归求解 Left -> d1"]
          Divide --> RecR["递归求解 Right -> d2"]
          RecL --> MinD["d = min(d1, d2)"]
          RecR --> MinD
          MinD --> Strip["检查中线 2d 宽度的条带"]
          Strip --> Final["返回 min(d, strip_min)"]
    - name: 快速选择算法
      coreIdea: 基于快速排序的划分思想，在未排序数组中找第 K 小的元素。
      steps: |
        1. 选择 pivot 并进行分区；
        2. 如果 pivot 位置恰好是 k，直接返回；
        3. 否则在 pivot 左侧或右侧递归查找。
      complexity: 平均 O(n)，最坏 O(n^2)。
      visualizationHint: 展示每次划分后如何缩小搜索范围。
    - name: 快速幂（分治）
      coreIdea: 计算 a^n 时，利用 a^n = (a^(n/2))^2 减少计算次数。
      steps: |
        1. 若 n = 0，返回 1；
        2. 若 n 为偶数，result = pow(a, n/2)^2；
        3. 若 n 为奇数，result = a * pow(a, n/2)^2。
      complexity: O(log n)。
      codeSnippet: |
        long pow(long a, int n) {
            if (n == 0) return 1;
            long half = pow(a, n / 2);
            return (n % 2 == 0) ? half * half : a * half * half;
        }

- title: 动态规划
  category: 算法思想
  overview: 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
  keywords:
    - 动态规划
    - 状态转移
    - 最优子结构
  difficultyLevel: 3
  algorithms:
    - name: 0-1 背包问题
      coreIdea: 对于一组物品，每种物品都有自己的重量和价值，在限定的总重量内，选择物品使得总价值最高。
      steps: |
        1. 定义状态 dp[i][w] 为前 i 个物品放入容量为 w 的背包的最大价值；
        2. 状态转移：dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i])；
        3. 最终结果为 dp[N][W]。
      complexity: 时间复杂度 O(NW)，空间复杂度 O(NW) 或 O(W)。
      codeSnippet: |
        for (int i = 1; i <= N; i++) {
            for (int w = 1; w <= W; w++) {
                if (wt[i-1] <= w) {
                    dp[i][w] = Math.max(dp[i-1][w], 
                                      dp[i-1][w-wt[i-1]] + val[i-1]);
                } else {
                    dp[i][w] = dp[i-1][w];
                }
            }
        }
      visualizationHint: 展示二维 DP 表格的填充过程。
      mermaidCode: |
        graph TD
          Start["开始: 计算 dp(i, w)"] --> Check{"物品 i 是否放得下?"}
          Check -- "放不下 (w < wt[i])" --> NoTake["不放: dp(i-1, w)"]
          Check -- "能放下" --> Compare{"比较: 放 vs 不放"}
          Compare -->|不放| Option1["保持: dp(i-1, w)"]
          Compare -->|放| Option2["更新: dp(i-1, w-wt[i]) + val[i]"]
          Option1 --> Max[取最大值]
          Option2 --> Max
          Max --> Result["存入 dp(i, w)"]
    - name: 最长公共子序列
      coreIdea: 寻找两个序列共有的最长子序列。
      steps: |
        1. 定义 dp[i][j] 为 text1[0..i] 和 text2[0..j] 的 LCS 长度；
        2. 若 text1[i] == text2[j]，dp[i][j] = dp[i-1][j-1] + 1；
        3. 否则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。
      complexity: 时间复杂度 O(mn)，空间复杂度 O(mn)。
      visualizationHint: 展示字符匹配时的对角线转移。
      mermaidCode: |
        graph TD
          State["dp[i][j]"] --> Check{"text1[i] == text2[j] ?"}
          Check -- Yes --> Match["dp[i-1][j-1] + 1 (对角线)"]
          Check -- No --> Mismatch["max(dp[i-1][j], dp[i][j-1])"]
          Mismatch --> Up["dp[i-1][j] (上方)"]
          Mismatch --> Left["dp[i][j-1] (左方)"]
          style Match fill:#bfb
          style Mismatch fill:#fbb
    - name: 编辑距离
      coreIdea: 计算将一个字符串转换为另一个字符串所需的最少操作次数（插入、删除、替换）。
      steps: |
        1. dp[i][j] 表示 word1[0..i-1] 转换为 word2[0..j-1] 的最小操作数；
        2. 若 word1[i-1] == word2[j-1]，dp[i][j] = dp[i-1][j-1]；
        3. 否则 dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])。
      complexity: O(mn)。
      visualizationHint: 展示三个方向的转移（插入、删除、替换）。
    - name: 最长递增子序列
      coreIdea: 找出数组中最长的严格递增子序列。
      steps: |
        1. dp[i] 表示以 nums[i] 结尾的最长递增子序列长度；
        2. dp[i] = max(dp[j] + 1)，其中 j < i 且 nums[j] < nums[i]；
        3. 答案为 max(dp[i])。
      complexity: 朴素 O(n^2)，二分优化 O(n log n)。
      codeSnippet: |
        // 二分优化版本
        List<Integer> tails = new ArrayList<>();
        for (int num : nums) {
            int pos = Collections.binarySearch(tails, num);
            if (pos < 0) pos = -(pos + 1);
            if (pos == tails.size()) tails.add(num);
            else tails.set(pos, num);
        }
        return tails.size();
    - name: 矩阵链乘法
      coreIdea: 确定矩阵连乘的最优括号化方案，使乘法次数最少。
      steps: |
        1. dp[i][j] 表示矩阵 i 到 j 连乘的最小代价；
        2. 枚举分割点 k: dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost(i,k,j))；
        3. 自底向上填充 DP 表。
      complexity: O(n^3)。
      visualizationHint: 展示不同分割点的代价比较。
    - name: 最大子数组和 (Kadane)
      coreIdea: 找到连续子数组的最大和。
      steps: |
        1. 维护 currentSum 和 maxSum；
        2. 遍历数组，currentSum = max(num, currentSum + num)；
        3. 更新 maxSum = max(maxSum, currentSum)。
      complexity: O(n)。
      codeSnippet: |
        int maxSum = nums[0], currentSum = nums[0];
        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            maxSum = Math.max(maxSum, currentSum);
        }
        return maxSum;

- title: 贪心算法
  category: 算法思想
  overview: 在对问题求解时，总是做出在当前看来是最好的选择。
  keywords:
    - 贪心
    - 局部最优
  difficultyLevel: 2
  algorithms:
    - name: 活动选择问题
      coreIdea: 每次选择结束时间最早且与已选活动不冲突的活动。
      steps: |
        1. 将活动按结束时间排序；
        2. 选择第一个活动；
        3. 依次检查后续活动，若开始时间 >= 上一个选中活动的结束时间，则选中。
      complexity: 排序 O(n log n) + 扫描 O(n)。
      visualizationHint: 时间轴上展示活动区间，高亮选中的活动。
      mermaidCode: |
        gantt
          title 活动选择示例
          dateFormat HH:mm
          axisFormat %H:%M
          section 活动安排
          活动1 (选) :done, a1, 08:00, 09:00
          活动2 (冲突) :active, a2, 08:30, 10:00
          活动3 (选) :done, a3, 09:10, 11:00
          活动4 (冲突) :active, a4, 10:00, 11:30
          活动5 (选) :done, a5, 11:10, 12:00
    - name: Huffman 编码
      coreIdea: 频率高的字符用短编码，频率低的用长编码，构建最优前缀码。
      steps: |
        1. 统计字符频率；
        2. 将每个字符看作单节点树，放入优先队列；
        3. 每次取出频率最小的两棵树合并，新树频率为两者之和，放回队列；
        4. 重复直到只剩一棵树。
      complexity: O(n log n)。
      mermaidCode: |
        graph TD
          A((58)) --> B((25))
          A --> C((33))
          B --> D(a: 10)
          B --> E(b: 15)
          C --> F(c: 12)
          C --> G((21))
          G --> H(d: 4)
          G --> I((17))
          I --> J(e: 8)
          I --> K(f: 9)
          style A fill:#f9f,stroke:#333
          style D fill:#ccf
          style E fill:#ccf
          style F fill:#ccf
          style H fill:#ccf
          style J fill:#ccf
          style K fill:#ccf
    - name: 分数背包
      coreIdea: 物品可以分割，每次选性价比最高的物品装入。
      steps: |
        1. 计算每个物品的单位价值（value/weight）；
        2. 按单位价值降序排序；
        3. 依次装入物品，可装满则全装，否则装剩余容量。
      complexity: O(n log n)。
      visualizationHint: 展示物品按性价比排序和装入过程。
    - name: 区间覆盖
      coreIdea: 用最少的区间覆盖给定范围。
      steps: |
        1. 将区间按起点排序；
        2. 贪心选择能覆盖当前未覆盖部分且右端点最远的区间；
        3. 重复直到覆盖完整范围。
      complexity: O(n log n)。

- title: 图算法
  category: 经典算法
  overview: 解决图结构相关问题的算法集合。
  keywords:
    - 图
    - 最短路径
    - 最小生成树
  difficultyLevel: 3
  algorithms:
    - name: Dijkstra 算法
      coreIdea: 从起点开始，每次选择当前距离最短的未访问节点，更新其邻居距离。
      steps: |
        1. 初始化 dist[]，起点为 0，其余无穷大；
        2. 使用优先队列维护未访问节点；
        3. 取出最小 dist 节点 u，松弛其所有邻居 v：if (dist[u] + w < dist[v]) dist[v] = dist[u] + w；
        4. 重复直到队列为空。
      complexity: O(E log V)。
      codeSnippet: |
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        while (!pq.isEmpty()) {
            Node u = pq.poll();
            if (visited[u.id]) continue;
            visited[u.id] = true;
            for (Edge e : adj[u.id]) {
                if (dist[u.id] + e.w < dist[e.to]) {
                    dist[e.to] = dist[u.id] + e.w;
                    pq.offer(new Node(e.to, dist[e.to]));
                }
            }
        }
      visualizationHint: 动态展示节点变色和距离更新过程。
      mermaidCode: |
        graph LR
          S((Start: 0)) -->|5| A((A: 5))
          S -->|2| B((B: 2))
          B -->|1| A
          B -->|4| C((C: 6))
          A -->|3| D((D: 8))
          C -->|1| D
          style S fill:#f9f
          style B fill:#bfb
          style A fill:#bfb
          style C fill:#bfb
          style D fill:#dfd
    - name: Bellman-Ford 算法
      coreIdea: 允许负权边的单源最短路径算法，能检测负环。
      steps: |
        1. 初始化 dist[]，起点为 0；
        2. 重复 V-1 次：松弛所有边；
        3. 再遍历所有边，若还能松弛则存在负环。
      complexity: O(VE)。
      visualizationHint: 展示多轮松弛过程和负环检测。
    - name: Floyd-Warshall 算法
      coreIdea: 求所有顶点对之间的最短路径。
      steps: |
        1. 初始化 dp[i][j] 为边权（无边则为无穷）；
        2. 枚举中间点 k，更新 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])；
        3. 遍历所有 k，i，j。
      complexity: O(V^3)。
      codeSnippet: |
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);
                }
            }
        }
    - name: Prim 算法
      coreIdea: 从任意节点开始，每次选择连接已选集合和未选集合的最小边。
      steps: |
        1. 维护 min_dist[] 表示节点到生成树的最小距离；
        2. 每次选 min_dist 最小的未访问节点加入生成树；
        3. 更新该节点邻居的 min_dist。
      complexity: O(E log V)。
      visualizationHint: 高亮显示逐步加入生成树的边。
      mermaidCode: |
        graph TD
          A((A)) ---|1| B((B))
          A ---|4| C((C))
          B ---|2| C
          B ---|5| D((D))
          C ---|1| D
          linkStyle 0 stroke:red,stroke-width:3px
          linkStyle 2 stroke:red,stroke-width:3px
          linkStyle 4 stroke:red,stroke-width:3px
          style A fill:#f9f
          style B fill:#f9f
          style C fill:#f9f
          style D fill:#f9f
    - name: Kruskal 算法
      coreIdea: 将边按权重排序，每次选最小边加入生成树（不形成环）。
      steps: |
        1. 将所有边按权重升序排序；
        2. 使用并查集维护连通性；
        3. 依次考虑每条边，若连接两个不同连通分量则加入。
      complexity: O(E log E)。
      visualizationHint: 展示边的选择顺序和并查集合并。
    - name: 广度优先搜索 (BFS)
      coreIdea: 从起点开始，逐层向外扩展，先访问离起点最近的节点。
      steps: |
        1. 将起点入队，标记已访问；
        2. 队列非空时，出队节点 u；
        3. 遍历 u 的所有未访问邻居，入队并标记。
      complexity: O(V + E)。
      visualizationHint: 展示波纹扩散式的访问顺序。
      mermaidCode: |
        graph TD
          Level0((L0)) --> Level1_A((L1-A))
          Level0 --> Level1_B((L1-B))
          Level1_A --> Level2_C((L2-C))
          Level1_A --> Level2_D((L2-D))
          Level1_B --> Level2_E((L2-E))
          style Level0 fill:#f9f
          style Level1_A fill:#bfb
          style Level1_B fill:#bfb
          style Level2_C fill:#dfd
          style Level2_D fill:#dfd
          style Level2_E fill:#dfd
    - name: 深度优先搜索 (DFS)
      coreIdea: 从起点开始，尽可能深地搜索分支，直到无法继续再回溯。
      steps: |
        1. 访问节点 u，标记已访问；
        2. 递归访问 u 的每一个未访问邻居；
        3. 所有邻居访问完后回溯。
      complexity: O(V + E)。
      visualizationHint: 展示一条路走到黑再回头的过程。
      mermaidCode: |
        graph TD
          Root --> A
          A --> B
          B -->|Back| A
          A --> C
          C --> D
          D -->|Back| C
          C -->|Back| A
          A -->|Back| Root
          style Root fill:#f9f
          style A fill:#bfb
          style B fill:#dfd
          style C fill:#bfb
          style D fill:#dfd
    - name: 拓扑排序
      coreIdea: 对有向无环图 (DAG) 进行排序，使得对于每条边 u->v，u 都在 v 之前。
      steps: |
        1. 统计所有节点入度；
        2. 将入度为 0 的节点入队；
        3. 出队节点 u，将其邻居 v 入度减 1，若 v 入度变 0 则入队。
      complexity: O(V + E)。
      visualizationHint: 展示节点入度减少和移除过程。
      mermaidCode: |
        graph LR
          TaskA[任务A] --> TaskC[任务C]
          TaskB[任务B] --> TaskC
          TaskC --> TaskD[任务D]
          TaskD --> TaskE[任务E]
          style TaskA fill:#bfb
          style TaskB fill:#bfb
          style TaskC fill:#dfd
          style TaskD fill:#efd
          style TaskE fill:#ffd

- title: 搜索与排序
  category: 基础算法
  overview: 基础的查找和排序算法。
  keywords:
    - 二分
    - 排序
  difficultyLevel: 1
  algorithms:
    - name: 二分查找
      coreIdea: 在有序数组中，每次比较中间元素，将搜索范围缩小一半。
      steps: |
        1. 设定左右边界 left, right；
        2. mid = (left + right) / 2；
        3. 若 arr[mid] == target，返回；若 < target，left = mid + 1；否则 right = mid - 1。
      complexity: O(log n)。
      codeSnippet: |
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
      visualizationHint: 展示左右指针移动和搜索区间缩小的过程。
      mermaidCode: |
        graph TD
          Range["[0 ... 10]"] -->|Mid=5 < Target| Right["[6 ... 10]"]
          Right -->|Mid=8 > Target| Left["[6 ... 7]"]
          Left -->|Mid=6 == Target| Found((Found))
          style Found fill:#f9f,stroke:#333
    - name: 快速排序
      coreIdea: 选定基准值，将小于基准的放左边，大于的放右边，递归排序。
      steps: |
        1. 选 pivot（如最后一个元素）；
        2. Partition 操作：将比 pivot 小的元素移到左侧；
        3. 递归处理左右两部分。
      complexity: 平均 O(n log n)，最坏 O(n^2)。
      visualizationHint: 展示 Pivot 的位置确定和数组划分。
      mermaidCode: |
        graph TD
          Arr[3, 1, 4, 1, 5, 9, 2, 6] -->|Pivot=6| Part[3, 1, 4, 1, 5, 2 | 6 | 9]
          Part -->|Left| L[3, 1, 4, 1, 5, 2]
          Part -->|Right| R[9]
          L -->|Pivot=2| LPart[1, 1 | 2 | 3, 4, 5]
          LPart -->|Sorted| LS[1, 1, 2, 3, 4, 5]
          R -->|Sorted| RS[9]
          LS --> Final
          RS --> Final
          Final[1, 1, 2, 3, 4, 5, 6, 9]
          style Final fill:#f9f
    - name: 堆排序
      coreIdea: 利用堆数据结构进行排序，先建最大堆，然后依次取出堆顶。
      steps: |
        1. 建立最大堆（从最后一个非叶子节点开始下沉）；
        2. 将堆顶（最大值）与末尾元素交换；
        3. 堆大小减 1，重新调整堆；
        4. 重复步骤 2-3。
      complexity: O(n log n)，空间 O(1)。
      code Snippet: |
        // 堆调整
        void heapify(int[] arr, int n, int i) {
            int largest = i;
            int left = 2 * i + 1, right = 2 * i + 2;
            if (left < n && arr[left] > arr[largest]) largest = left;
            if (right < n && arr[right] > arr[largest]) largest = right;
            if (largest != i) {
                swap(arr, i, largest);
                heapify(arr, n, largest);
            }
        }
    - name: 计数排序
      coreIdea: 统计每个元素出现次数，然后按顺序输出。
      steps: |
        1. 统计每个值的出现次数；
        2. 计算累计次数（确定位置）；
        3. 从后向前遍历原数组，放入正确位置。
      complexity: O(n + k)，k 为值域范围。
      visualizationHint: 非比较排序，适合值域较小的情况。
    - name: 桶排序
      coreIdea: 将元素分配到不同的桶中，桶内排序后合并。
      steps: |
        1. 确定桶的数量和范围；
        2. 将元素分配到对应的桶；
        3. 桶内排序（插入排序或快排）；
        4. 按顺序合并所有桶。
      complexity: 平均 O(n + k)，k 为桶数量。
    - name: 基数排序
      coreIdea: 按位数从低到高依次进行稳定排序。
      steps: |
        1. 从最低位开始；
        2. 对当前位进行计数排序（稳定）；
        3. 继续下一位，直到最高位。
      complexity: O(d * (n + k))，d 为位数。

- title: 字符串算法
  category: 经典算法
  overview: 处理字符串匹配和操作的算法。
  keywords:
    - KMP
    - 字符串匹配
  difficultyLevel: 3
  algorithms:
    - name: KMP 算法
      coreIdea: 利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。
      steps: |
        1. 构建 Next 数组（最长公共前后缀）；
        2. 匹配时若失配，根据 Next 数组移动模式串，而不是回退主串指针。
      complexity: O(M + N)。
      visualizationHint: 展示模式串在失配时的跳跃移动。
      mermaidCode: |
        graph TD
          Text[文本: A B A B A B C]
          Pattern[模式: A B A B C]
          Match1[匹配: A B A B ...] -->|C != A| Fail[失配!]
          Fail -->|查 Next 表| Shift[模式串右移 2 位]
          Shift --> Retry[新匹配: ... A B A B C]
          Retry --> Success((匹配成功))
          style Success fill:#f9f
    - name: Rabin-Karp 算法
      coreIdea: 使用哈希函数快速比较子串，利用滚动哈希提高效率。
      steps: |
        1. 计算模式串的哈希值；
        2. 计算文本串中每个长度为 m 的子串哈希值；
        3. 若哈希值相等，再逐字符比较确认。
      complexity: 平均 O(n + m)，最坏 O(nm)。
    - name: Boyer-Moore 算法
      coreIdea: 从模式串末尾开始匹配，利用坏字符和好后缀规则跳过更多字符。
      steps: |
        1. 预处理模式串，建立坏字符表和好后缀表；
        2. 从右向左匹配；
        3. 失配时根据两个表计算跳跃距离。
      complexity: 平均 O(n/m)，最坏 O(nm)。
    - name: Trie 树（字典树）
      coreIdea: 多叉树结构，用于高效存储和查找字符串集合。
      steps: |
        1. 每个节点包含若干子节点（通常26个字母）；
        2. 从根到某节点的路径代表一个前缀；
        3. 插入、查找都是 O(L)，L 为字符串长度。
      visualizationHint: 展示树的分叉结构和前缀共享。
    - name: AC 自动机
      coreIdea: 在 Trie 树基础上增加失配指针，实现多模式串匹配。
      steps: |
        1. 构建所有模式串的 Trie 树；
        2. 利用 BFS 构建 fail 指针；
        3. 遍历文本串，根据 fail 指针跳转。
      complexity: O(n + m + z)，z 为匹配次数。

- title: 回溯算法
  category: 算法思想
  overview: 通过递归尝试所有可能的解，遇到不满足条件时回退。
  keywords:
    - 回溯
    - 剪枝
    - 递归
  difficultyLevel: 3
  algorithms:
    - name: N 皇后问题
      coreIdea: 在 N×N 棋盘上放置 N 个皇后，使它们互不攻击。
      steps: |
        1. 逐行放置皇后；
        2. 检查当前列、对角线是否有冲突；
        3. 无冲突则继续下一行，否则回溯。
      complexity: O(N!)。
      visualizationHint: 展示棋盘状态和回溯过程。
    - name:  全排列
      coreIdea: 生成数组的所有排列。
      steps: |
        1. 使用 used 数组标记已选元素；
        2. 递归选择未使用的元素；
        3. 到达叶子节点时记录排列。
      complexity: O(N * N!)。
      codeSnippet: |
        void backtrack(List<Integer> path, boolean[] used) {
            if (path.size() == nums.length) {
                result.add(new ArrayList<>(path));
                return;
            }
            for (int i = 0; i < nums.length; i++) {
                if (used[i]) continue;
                used[i] = true;
                path.add(nums[i]);
                backtrack(path, used);
                path.remove(path.size() - 1);
                used[i] = false;
            }
        }
    - name: 子集生成
      coreIdea: 生成集合的所有子集（幂集）。
      steps: |
        1. 对每个元素，选择包含或不包含；
        2. 递归遍历所有可能；
        3. 每个叶子节点对应一个子集。
      complexity: O(2^N)。
    - name: 组合总和
      coreIdea: 找出所有和为目标值的数字组合。
      steps: |
        1. 从当前位置开始选择数字；
        2. 递归搜索剩余target - current；
        3. 剪枝：若已超target则回退。
      complexity: 指数级，具体取决于目标值和候选数。
    - name: 数独求解器
      coreIdea: 填充数独使每行、每列、每个 3×3 宫格数字不重复。
      steps: |
        1. 找到空格；
        2. 尝试填入 1-9；
        3. 检查是否合法，递归填下一个格子；
        4. 若无解则回溯。
      complexity: 最坏 O(9^m)，m 为空格数。

- title: 数据结构算法
  category: 经典算法
  overview: 高效数据结构的实现和应用。
  keywords:
    - 并查集
    - 堆
    - 树
  difficultyLevel: 2
  algorithms:
    - name: 并查集
      coreIdea: 维护元素的分组信息，支持快速合并和查询。
      steps: |
        1. Find: 查找元素所属集合的代表元（路径压缩）；
        2. Union: 合并两个集合（按秩合并）。
      complexity: 几乎 O(1)（摊销）。
      codeSnippet: |
        int find(int x) {
            if (parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }
        void union(int x, int y) {
            int px = find(x), py = find(y);
            if (rank[px] < rank[py]) parent[px] = py;
            else if (rank[px] > rank[py]) parent[py] = px;
            else { parent[py] = px; rank[px]++; }
        }
    - name: 线段树
      coreIdea: 树状结构维护区间信息，支持区间查询和修改。
      steps: |
        1. 建树：递归构建，每个节点存区间统计值；
        2. 查询：递归查询子区间并合并；
        3. 更新：递归更新并回溯更新父节点。
      complexity: 建树 O(n)，查询/更新 O(log n)。
    - name: 树状数组 (Fenwick Tree)
      coreIdea: 用数组模拟树结构，维护前缀和。
      steps: |
        1. Update: 更新 index 及其父节点；
        2. Query: 查询前缀和，累加至 index 祖先节点。
      complexity: O(log n)。
      codeSnippet: |
        // 单点更新
        void update(int i, int delta) {
            while (i <= n) {
                tree[i] += delta;
                i += i & (-i);
            }
        }
        // 查询前缀和
        int query(int i) {
            int sum = 0;
            while (i > 0) {
                sum += tree[i];
                i -= i & (-i);
            }
            return sum;
        }
    - name: 最小堆/最大堆
      coreIdea: 完全二叉树，父节点小于（或大于）子节点。
      steps: |
        1. 插入：添加到末尾，上浮调整；
        2. 删除：取出堆顶，末尾元素放到顶部，下沉调整。
      complexity: 插入/删除 O(log n)，取最小值 O(1)。
    - name: 单调栈
      coreIdea: 维护一个单调递增或递减的栈，快速找到左/右第一个更大/小的元素。
      steps: |
        1. 遍历数组；
        2. 弹出栈顶不满足单调性的元素；
        3. 当前元素入栈。
      complexity: O(n)。
      visualizationHint: 展示栈的弹入弹出过程。

- title: 数论算法
  category: 经典算法
  overview: 数学和数论相关的经典算法。
  keywords:
    - 素数
    - GCD
    - 模运算
  difficultyLevel: 2
  algorithms:
    - name: 欧几里得算法 (GCD)
      coreIdea: 求两个数的最大公约数。
      steps: |
        1. gcd(a, b) = gcd(b, a mod b)；
        2. 递归直到 b = 0，此时 a 即为 GCD。
      complexity: O(log min(a, b))。
      codeSnippet: |
        int gcd(int a, int b) {
            return b == 0 ? a : gcd(b, a % b);
        }
    - name: 扩展欧几里得算法
      coreIdea: 求解 ax + by = gcd(a, b) 的整数解。
      steps: |
        1. 递归求 gcd；
        2. 回溯时计算系数 x, y。
      complexity: O(log min(a, b))。
    - name: 快速幂（模运算）
      coreIdea: 计算 a^n mod m。
      steps: |
        1. 若 n 为偶数，a^n = (a^(n/2))^2；
        2. 若 n 为奇数，a^n = a * (a^(n/2))^2；
        3. 每步取模防止溢出。
      complexity: O(log n)。
      codeSnippet: |
        long modPow(long a, long n, long mod) {
            long res = 1;
            while (n > 0) {
                if ((n & 1) == 1) res = res * a % mod;
                a = a * a % mod;
                n >>= 1;
            }
            return res;
        }
    - name: 埃氏筛法（素数筛选）
      coreIdea: 筛选出一定范围内的所有素数。
      steps: |
        1. 初始化所有数为素数；
        2. 从 2 开始，将其倍数标记为合数；
        3. 重复直到 sqrt(n)。
      complexity: O(n log log n)。
    - name: 线性筛（欧拉筛）
      coreIdea: 更高效的素数筛选，每个合数只被其最小质因子筛掉一次。
      steps: |
        1. 维护已找到的质数列表；
        2. 对每个数 i，用已知质数筛掉 i * primes[j]；
        3. 若 i % primes[j] == 0 则停止。
      complexity: O(n)。
    - name: 中国剩余定理
      coreIdea: 求解一组同余方程组。
      steps: |
        1. 确保模数两两互质；
        2. 构造特解并求和；
        3. 对乘积取模得最终解。
      complexity: O(k log M)，k 为方程数。

- title: 位运算技巧
  category: 技巧
  overview: 利用位运算解决问题的技巧。
  keywords:
    - 位运算
    - 异或
    - 位掩码
  difficultyLevel: 2
  algorithms:
    - name: 找出唯一数（异或）
      coreIdea: 数组中只有一个数出现一次，其他都出现两次，找出这个数。
      steps: |
        1. 所有数异或，相同的数异或为 0；
        2. 最终结果即为唯一数。
      complexity: O(n)。
      codeSnippet: |
        int result = 0;
        for (int num : nums) result ^= num;
        return result;
    - name: 计算二进制中 1 的个数
      coreIdea: 统计一个数的二进制表示中有多少个 1。
      steps: |
        1. n & (n-1) 可以消除最低位的 1；
        2. 重复直到 n 变为 0。
      complexity: O(k)，k 为 1 的个数。
      codeSnippet: |
        int count = 0;
        while (n != 0) {
            n &= (n - 1);
            count++;
        }
        return count;
    - name: 判断是否为 2 的幂
      coreIdea: 2 的幂的二进制只有一个 1。
      steps: |
        1. n & (n-1) == 0 且 n > 0。
      complexity: O(1)。
    - name: 位掩码 DP
      coreIdea: 用整数的二进制位表示状态，进行动态规划。
      steps: |
        1. 每一位代表某个元素是否被选中；
        2. 状态转移通过位运算实现；
        3. 适用于集合问题（如旅行商问题）。
      complexity: O(2^n * poly(n))。
    - name: 交换两数（无临时变量）
      coreIdea: 利用异或交换两个数。
      steps: |
        1. a ^= b;
        2. b ^= a;
        3. a ^= b;
      complexity: O(1)。
  

- title: 高级数据结构
  category: 高级算法
  overview: 复杂数据结构的实现与应用，支持高效的数据操作。
  keywords:
    - 平衡树
    - 跳表
    - B树
  difficultyLevel: 4
  algorithms:
    - name: 红黑树
      coreIdea: 自平衡二叉搜索树，通过着色和旋转保持平衡。
      steps: |
        1. 插入节点并着红色；
        2. 修复红黑性质（父子不能都是红）；
        3. 通过旋转和重新着色调整；
        4. 保证从根到叶的最长路径不超过最短路径的2倍。
      complexity: 插入/删除/查找均为 O(log n)。
      visualizationHint: 展示红黑节点和旋转过程。
    - name: AVL 树
      coreIdea: 严格平衡的二叉搜索树，任何节点的左右子树高度差不超过1。
      steps: |
        1. 按BST规则插入；
        2. 回溯更新每个祖先的平衡因子；
        3. 若|平衡因子| > 1，执行旋转（LL/RR/LR/RL）。
      complexity: O(log n)，比红黑树平衡性更好但旋转次数略多。
    - name: B 树
      coreIdea: 多路平衡搜索树，每个节点可有多个键和子节点，适合磁盘存储。
      steps: |
        1. 插入到叶节点；
        2. 若节点溢出（键数 > 2t-1），分裂节点；
        3. 中间键提升到父节点；
        4. 递归向上处理。
      complexity: O(log n)，磁盘IO次数少。
      visualizationHint: 展示节点分裂和合并。
    - name: B+ 树
      coreIdea: B树的变种，所有数据存在叶节点，叶节点间有链表连接。
      steps: |
        1. 内部节点只存索引；
        2. 叶节点存完整数据并链接；
        3. 支持高效范围查询。
      complexity: O(log n)，范围查询性能优异。
    - name: 跳表
      coreIdea: 多层链表结构，通过随机化实现类似平衡树的性能。
      steps: |
        1. 最底层是完整有序链表；
        2. 上层是下层的"快速通道"；
        3. 查找时从顶层开始，不断下降；
        4. 插入时随机决定节点高度。
      complexity: 平均 O(log n)，实现简单。
      codeSnippet: |
        class SkipNode {
            int val;
            SkipNode[] forward; // 各层的前进指针
            SkipNode(int val, int level) {
                this.val = val;
                forward = new SkipNode[level];
            }
        }
    - name: 伸展树 (Splay Tree)
      coreIdea: 自调整二叉搜索树，最近访问的节点会被旋转到根部。
      steps: |
        1. 查找节点；
        2. 通过 zig/zig-zig/zig-zag 旋转将节点移到根；
        3. 保证均摊 O(log n)。
      complexity: 均摊 O(log n)，单次可能 O(n)。
    - name: 笛卡尔树 (Treap)
      coreIdea: 结合二叉搜索树和堆的性质，通过随机优先级维护平衡。
      steps: |
        1. 键值满足BST性质；
        2. 优先级满足堆性质；
        3. 通过旋转维护两个性质。
      complexity: 期望 O(log n)。

- title: 图论进阶
  category: 高级算法
  overview: 复杂图问题的高级算法。
  keywords:
    - 网络流
    - 匹配
    - 连通性
  difficultyLevel: 4
  algorithms:
    - name: 最大流算法 (Ford-Fulkerson)
      coreIdea: 不断寻找增广路径，直到无法增加流量为止。
      steps: |
        1. 初始化流为0；
        2. 找到一条从源到汇的增广路径；
        3. 沿路径增加流量（路径上最小容量）；
        4. 更新残余网络；
        5. 重复直到无增广路径。
      complexity: O(E * max_flow)，取决于路径选择策略。
    - name: Dinic 算法
      coreIdea: 分层图 + 多路增广优化的最大流算法。
      steps: |
        1. BFS构建分层图；
        2. DFS在分层图中找增广路并增流；
        3. 重复直到无法分层。
      complexity: O(V^2 * E)。
    - name: 最小割 (Min-Cut)
      coreIdea: 最大流等于最小割（Max-Flow Min-Cut 定理）。
      steps: |
        1. 求最大流；
        2. 从源点在残余网络上DFS；
        3. 能到达的点和不能到达的点之间的边构成最小割。
      complexity: 同最大流算法。
    - name: 二分图最大匹配 (Hungarian算法)
      coreIdea: 通过增广路找到二分图的最大匹配。
      steps: |
        1. 初始化空匹配；
        2. 对每个未匹配左顶点，DFS找增广路；
        3. 若找到，更新匹配；
        4. 重复直到无增广路。
      complexity: O(V * E)。
      visualizationHint: 展示二分图和匹配边。
    - name: 强连通分量 (Kosaraju算法)
      coreIdea: 找出有向图中的所有强连通分量。
      steps: |
        1. 对原图进行DFS，记录结束时间；
        2. 对转置图按结束时间倒序DFS；
        3. 每次DFS到达的节点构成一个强连通分量。
      complexity: O(V + E)。
    - name: Tarjan算法（强连通分量）
      coreIdea: 一次DFS找出所有强连通分量。
      steps: |
        1. 维护时间戳和low值；
        2. DFS遍历，用栈记录当前路径；
        3. 当 low[u] == dfn[u] 时，栈中u及其上方节点构成SCC。
      complexity: O(V + E)。
      codeSnippet: |
        void tarjan(int u) {
            dfn[u] = low[u] = ++timestamp;
            stack.push(u);
            inStack[u] = true;
            for (int v : graph[u]) {
                if (dfn[v] == 0) {
                    tarjan(v);
                    low[u] = Math.min(low[u], low[v]);
                } else if (inStack[v]) {
                    low[u] = Math.min(low[u], dfn[v]);
                }
            }
            if (dfn[u] == low[u]) {
                // 找到一个SCC
                while (stack.peek() != u) {
                    int v = stack.pop();
                    inStack[v] = false;
                    scc[v] = sccCount;
                }
                stack.pop();
                inStack[u] = false;
                sccCount++;
            }
        }
    - name: 欧拉回路
      coreIdea: 遍历图中每条边恰好一次的回路。
      steps: |
        1. 检查是否存在欧拉回路（所有顶点度数为偶数）；
        2. 从任意顶点开始DFS；
        3. 删除已访问边，回溯时记录路径。
      complexity: O(E)。
    - name: 哈密尔顿回路
      coreIdea: 遍历图中每个顶点恰好一次的回路。
      steps: |
        1. 回溯搜索所有路径；
        2. 剪枝优化；
        3. NP完全问题，无多项式算法。
      complexity: 指数级。
    - name: 2-SAT问题
      coreIdea: 布尔可满足性问题的特例，每个子句恰好包含2个变量。
      steps: |
        1. 构建蕴含图；
        2. 找强连通分量；
        3. 若变量x和¬x在同一SCC中，则无解。
      complexity: O(V + E)。

- title: 计算几何
  category: 高级算法
  overview: 处理几何图形和空间问题的算法。
  keywords:
    - 凸包
    - 线段相交
    - 最近点对
  difficultyLevel: 4
  algorithms:
    - name: Graham 扫描（凸包）
      coreIdea: 找出平面点集的凸包。
      steps: |
        1. 找到最下方的点作为起点；
        2. 按极角排序其他点；
        3. 用栈维护凸包，遇到右转则弹栈；
        4. 最终栈中的点构成凸包。
      complexity: O(n log n)。
      visualizationHint: 展示极角排序和栈的弹入弹出。
    - name: Jarvis 步进（凸包）
      coreIdea: 从最左点开始，每次选择极角最小的下一个点。
      steps: |
        1. 从最左点开始；
        2. 找到相对当前点极角最小的下一个点；
        3. 重复直到回到起点。
      complexity: O(nh)，h为凸包顶点数。
    - name: 旋转卡壳
      coreIdea: 在凸包上寻找最远点对、最小外接矩形等。
      steps: |
        1. 维护两个"卡壳"（平行线）；
        2. 旋转卡壳，更新答案；
        3. 遍历所有方向。
      complexity: O(n)（基于已知凸包）。
    - name: 线段相交判定
      coreIdea: 判断两条线段是否相交。
      steps: |
        1. 快速排斥试验：检查外接矩形是否相交；
        2. 跨立试验：检查端点是否在对方线段两侧；
        3. 使用叉积判断方向。
      complexity: O(1)。
      codeSnippet: |
        // 叉积
        double cross(Point a, Point b, Point c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }
        boolean intersect(Segment s1, Segment s2) {
            return cross(s1.p1, s1.p2, s2.p1) * cross(s1.p1, s1.p2, s2.p2) <= 0 &&
                   cross(s2.p1, s2.p2, s1.p1) * cross(s2.p1, s2.p2, s1.p2) <= 0;
        }
    - name: 点在多边形内判定
      coreIdea: 判断点是否在多边形内部。
      steps: |
        1. 射线法：从点引一条射线；
        2. 统计与多边形边的交点数；
        3. 奇数则在内部，偶数则在外部。
      complexity: O(n)。
    - name: 最近点对（分治）
      coreIdea: 平面上找最近的两个点。
      steps: |
        1. 按x坐标排序并分治；
        2. 递归求左右最小距离d；
        3. 检查中间条带2d宽度内的点对。
      complexity: O(n log n)。
    - name: 多边形面积
      coreIdea: 计算简单多边形的面积。
      steps: |
        1. 使用叉积累加；
        2. 面积 = 0.5 * |Σ(x[i] * y[i+1] - x[i+1] * y[i])|。
      complexity: O(n)。

- title: 字符串高级算法
  category: 高级算法
  overview: 高级字符串处理和模式匹配算法。
  keywords:
    - 后缀
    - 自动机
    - 回文
  difficultyLevel: 4
  algorithms:
    - name: 后缀数组 (Suffix Array)
      coreIdea: 所有后缀按字典序排序的数组，支持高效字符串查询。
      steps: |
        1. 构建所有后缀；
        2. 按字典序排序（倍增算法优化）；
        3. 构建LCP数组（最长公共前缀）。
      complexity: 构建 O(n log n)，查询 O(log n)。
    - name: 后缀树 (Suffix Tree)
      coreIdea: 压缩的Trie树，存储所有后缀。
      steps: |
        1. 使用Ukkonen算法线性构建；
        2. 每个后缀对应从根到叶的一条路径；
        3. 支持快速子串查询。
      complexity: O(n) 构建，O(m) 查询。
    - name: Manacher 算法
      coreIdea: 线性时间找出所有回文子串。
      steps: |
        1. 在字符间插入分隔符（处理奇偶长度）；
        2. 维护当前最右回文边界；
        3. 利用对称性快速计算回文半径。
      complexity: O(n)。
      codeSnippet: |
        String preprocess(String s) {
            StringBuilder sb = new StringBuilder("^#");
            for (char c : s.toCharArray()) {
                sb.append(c).append('#');
            }
            return sb.append('$').toString();
        }
    - name: Z 算法
      coreIdea: 计算字符串每个位置与前缀的最长公共前缀长度。
      steps: |
        1. 维护最右匹配区间 [l, r]；
        2. 利用已知信息快速计算 Z[i]；
        3. 需要时扩展匹配区间。
      complexity: O(n)。
    - name: Aho-Corasick 自动机细节
      coreIdea: 多模式匹配自动机的构建细节。
      steps: |
        1. 构建Trie树；
        2. BFS构建fail指针（类似KMP）；
        3. 添加输出链接指针优化多次匹配。
      complexity: O(n + m + z)。
    - name: 最长回文子串
      coreIdea: 找出字符串中最长的回文子串。
      steps: |
        1. 中心扩展法：枚举每个中心；
        2. 或使用Manacher算法O(n)；
        3. 或DP: dp[i][j] 表示 s[i..j] 是否回文。
      complexity: 中心扩展 O(n^2)，Manacher O(n)，DP O(n^2)。

- title: 动态规划进阶
  category: 高级算法
  overview: 复杂DP问题和优化技巧。
  keywords:
    - 状态压缩
    - 区间DP
    - 树形DP
  difficultyLevel: 4
  algorithms:
    - name: 状态压缩DP
      coreIdea: 用二进制表示状态，压缩DP维度。
      steps: |
        1. 用整数的位表示集合状态；
        2. 状态转移通过位运算；
        3. 适合集合大小 <= 20 的问题。
      complexity: O(2^n * poly(n))。
      codeSnippet: |
        // 旅行商问题（TSP）
        int[][] dp = new int[1 << n][n]; // dp[mask][i] 表示访问mask集合，当前在i
        for (int mask = 0; mask < (1 << n); mask++) {
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) == 0) continue;
                for (int j = 0; j < n; j++) {
                    if ((mask & (1 << j)) != 0) continue;
                    int newMask = mask | (1 << j);
                    dp[newMask][j] = Math.min(dp[newMask][j], 
                                             dp[mask][i] + dist[i][j]);
                }
            }
        }
    - name: 区间DP
      coreIdea: 在区间上定义状态，通常枚举区间长度。
      steps: |
        1. dp[i][j] 表示区间 [i, j] 的最优解；
        2. 枚举分割点 k: dp[i][j] = opt(dp[i][k] + dp[k+1][j] + cost)；
        3. 从小区间到大区间递推。
      complexity: 通常 O(n^3)。
    - name: 树形DP
      coreIdea: 在树结构上进行DP。
      steps: |
        1. 定义 dp[u][0/1] 表示以u为根的子树选/不选u的最优解；
        2. 后序遍历，从叶子向根递推；
        3. 合并子节点信息。
      complexity: O(n)。
      codeSnippet: |
        // 树的最大独立集
        void dfs(int u, int parent) {
            dp[u][0] = 0; // 不选u
            dp[u][1] = val[u]; // 选u
            for (int v : adj[u]) {
                if (v == parent) continue;
                dfs(v, u);
                dp[u][0] += Math.max(dp[v][0], dp[v][1]);
                dp[u][1] += dp[v][0]; // 选u则不能选子节点
            }
        }
    - name: 数位DP
      coreIdea: 统计满足某种性质的数的个数。
      steps: |
        1. 按位处理数字；
        2. 记录是否达到上界、是否有前导零等状态；
        3. 递归+记忆化。
      complexity: O(log n * 状态数)。
    - name: 斜率优化DP
      coreIdea: 通过维护凸包优化DP转移。
      steps: |
        1. 将DP转移写成斜率形式；
        2. 维护下凸壳（单调队列）；
        3. 用二分或单调性快速找最优转移点。
      complexity: 从 O(n^2) 优化到 O(n log n) 或 O(n)。
    - name: 四边形不等式优化
      coreIdea: 利用决策单调性优化区间DP。
      steps: |
        1. 证明决策函数满足四边形不等式；
        2. 维护决策区间；
        3. 避免枚举所有分割点。
      complexity: 从 O(n^3) 优化到 O(n^2)。

- title: 概率与随机算法
  category: 高级算法
  overview: 利用随机化策略解决问题的算法。
  keywords:
    - 蒙特卡洛
    - 随机化
    - 概率
  difficultyLevel: 3
  algorithms:
    - name: 蒙特卡洛算法（圆周率估算）
      coreIdea: 通过随机采样估算数学值。
      steps: |
        1. 在正方形内随机生成点；
        2. 统计落在内接圆内的点数；
        3. π ≈ 4 * (圆内点数 / 总点数)。
      complexity: O(n)，n为采样次数。
    - name: 随机化快速选择
      coreIdea: 随机选择pivot优化快速选择算法。
      steps: |
        1. 随机选择pivot；
        2. 分区并递归；
        3. 期望线性时间。
      complexity: 期望 O(n)，最坏 O(n^2)。
    - name: Reservoir Sampling（蓄水池抽样）
      coreIdea: 从数据流中等概率抽样k个元素。
      steps: |
        1. 前k个元素直接放入蓄水池；
        2. 第i个元素(i>k)以 k/i 概率替换蓄水池中随机元素；
        3. 保证每个元素被选中概率为 k/n。
      complexity: O(n)，空间 O(k)。
      codeSnippet: |
        int[] reservoir = new int[k];
        Random rand = new Random();
        for (int i = 0; i < stream.length; i++) {
            if (i < k) {
                reservoir[i] = stream[i];
            } else {
                int j = rand.nextInt(i + 1);
                if (j < k) reservoir[j] = stream[i];
            }
        }
    - name: Miller-Rabin 素性测试
      coreIdea: 概率算法判断大数是否为素数。
      steps: |
        1. 选择随机基a；
        2. 计算 a^(n-1) mod n；
        3. 多轮测试，减少误判概率。
      complexity: O(k log^3 n)，k为测试轮数。
    - name: 布隆过滤器 (Bloom Filter)
      coreIdea: 空间高效的概率数据结构，判断元素是否可能在集合中。
      steps: |
        1. 使用k个哈希函数；
        2. 插入时设置k个位为1；
        3. 查询时检查k个位是否都为1。
      complexity: O(k)，允许假阳性但无假阴性。
    - name: Skip List 随机化
      coreIdea: 通过随机决定节点层数实现期望平衡。
      steps: |
        1. 插入时抛硬币决定层数；
        2. 期望log n层；
        3. 避免复杂的平衡调整。
      complexity: 期望 O(log n)。

- title: 近似算法
  category: 高级算法
  overview: 对NP困难问题的近似求解算法。
  keywords:
    - NP困难
    - 近似比
    - 启发式
  difficultyLevel: 4
  algorithms:
    - name: 顶点覆盖近似算法
      coreIdea: 找最小顶点集覆盖所有边。
      steps: |
        1. 不断选择未覆盖的边(u,v)；
        2. 将u和v都加入顶点集；
        3. 删除被覆盖的边。
      complexity: O(E)，近似比为2。
    - name: TSP 近似算法（MST方法）
      coreIdea: 通过最小生成树近似旅行商问题。
      steps: |
        1. 构建MST；
        2. DFS遍历MST得到欧拉回路；
        3. 跳过重复顶点得到哈密尔顿回路。
      complexity: O(V^2)，近似比为2（满足三角不等式）。
    - name: 装箱问题 (Bin Packing)
      coreIdea: 用最少的箱子装下所有物品。
      steps: |
        1. First Fit: 放入第一个能装下的箱子；
        2. Best Fit: 放入剩余空间最小的箱子；
        3. First Fit Decreasing: 先按大小降序排序。
      complexity: O(n log n)，FFD近似比为 11/9。
    - name: 集合覆盖贪心算法
      coreIdea: 用最少的集合覆盖所有元素。
      steps: |
        1. 每次选择覆盖最多未覆盖元素的集合；
        2. 重复直到所有元素被覆盖。
      complexity: O(U * S)，近似比为 ln n + 1。
    - name: 背包问题 FPTAS
      coreIdea: 全多项式时间近似方案。
      steps: |
        1. 缩放价值（除以某个因子）；
        2. 用伪多项式DP求解；
        3. 得到 (1-ε) 近似解。
      complexity: O(n^3 / ε)。

- title: 并行与分布式算法
  category: 高级算法
  overview: 利用并行计算提高效率的算法。
  keywords:
    - 并行
    - MapReduce
    - PRAM
  difficultyLevel: 4
  algorithms:
    - name: 并行归并排序
      coreIdea: 递归分治部分并行执行。
      steps: |
        1. 将数组分成p份；
        2. 并行排序每份；
        3. 多路归并。
      complexity: O((n log n) / p + log p)。
    - name: 并行前缀和 (Prefix Sum)
      coreIdea: 并行计算累加和数组。
      steps: |
        1. 使用二叉树结构；
        2. 上扫阶段：并行计算部分和；
        3. 下扫阶段：并行分发前缀和。
      complexity: O(log n) 步，O(n) 工作量。
    - name: MapReduce 框架
      coreIdea: 大数据处理的编程模型。
      steps: |
        1. Map: 并行处理输入数据，生成键值对；
        2. Shuffle: 按键分组；
        3. Reduce: 并行聚合每个键的值。
      complexity: 取决于具体问题和集群规模。
      visualizationHint: 展示Map和Reduce阶段的数据流。
    - name: 并行BFS
      coreIdea: 层次遍历时并行处理同一层的节点。
      steps: |
        1. 维护当前层队列；
        2. 并行处理队列中所有节点；
        3. 收集下一层节点。
      complexity: O(V + E / p)，p为处理器数。
    - name: 分布式哈希表 (DHT)
      coreIdea: 在多台机器间分布存储键值对。
      steps: |
        1. 一致性哈希分配数据到节点；
        2. 节点间协作查找；
        3. 支持动态加入/离开。
      complexity: O(log n) 跳数（Chord等协议）。
