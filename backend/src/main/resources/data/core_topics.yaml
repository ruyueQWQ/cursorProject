- title: 分治策略
  category: 算法思想
  overview: 通过将问题拆分为子问题并递归求解，再合并结果以得到整体解。
  keywords:
    - 分治
    - 递归
    - 主定理
  difficultyLevel: 2
  algorithms:
    - name: 归并排序
      coreIdea: 将数组一分为二，递归排序，再在合并阶段保持有序。
      steps: |
        1. 将数组拆成两个子数组；
        2. 分别递归排序子数组；
        3. 双指针线性合并。
      complexity: 时间复杂度 O(n log n)，空间复杂度 O(n)。
      codeSnippet: |
        public void mergeSort(int[] arr, int left, int right) {
            if (left >= right) return;
            int mid = (left + right) >> 1;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
      visualizationHint: 使用分治树展示拆分和合并。
      mermaidCode: |
        graph TD
          A[8, 4, 5, 7, 1, 3, 6, 2] -->|Split| B[8, 4, 5, 7]
          A -->|Split| C[1, 3, 6, 2]
          B -->|Split| D[8, 4]
          B -->|Split| E[5, 7]
          C -->|Split| F[1, 3]
          C -->|Split| G[6, 2]
          D -->|Split| H[8]
          D -->|Split| I[4]
          H -->|Merge| J[4, 8]
          I -->|Merge| J
          E -->|Merge| K[5, 7]
          F -->|Merge| L[1, 3]
          G -->|Merge| M[2, 6]
          J -->|Merge| N[4, 5, 7, 8]
          K -->|Merge| N
          L -->|Merge| O[1, 2, 3, 6]
          M -->|Merge| O
          N -->|Merge| P[1, 2, 3, 4, 5, 6, 7, 8]
          style P fill:#f9f,stroke:#333,stroke-width:4px
    - name: 最近点对
      coreIdea: 先按坐标排序，按中线分成两部分，递归求解，再在跨区带内扫描。
      steps: |
        1. 按 x 轴排序；
        2. 递归求解左右最小距离；
        3. 在带宽 2d 条带中检查跨区点对。
      complexity: 平均与最坏时间复杂度皆为 O(n log n)。
- title: 动态规划
  category: 算法思想
  overview: 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
  keywords:
    - 动态规划
    - 状态转移
    - 最优子结构
  difficultyLevel: 3
  algorithms:
    - name: 0-1 背包问题
      coreIdea: 对于一组物品，每种物品都有自己的重量和价值，在限定的总重量内，选择物品使得总价值最高。
      steps: |
        1. 定义状态 dp[i][w] 为前 i 个物品放入容量为 w 的背包的最大价值；
        2. 状态转移：dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i])；
        3. 最终结果为 dp[N][W]。
      complexity: 时间复杂度 O(NW)，空间复杂度 O(NW) 或 O(W)。
      codeSnippet: |
        for (int i = 1; i <= N; i++) {
            for (int w = 1; w <= W; w++) {
                if (wt[i-1] <= w) {
                    dp[i][w] = Math.max(dp[i-1][w], 
                                      dp[i-1][w-wt[i-1]] + val[i-1]);
                } else {
                    dp[i][w] = dp[i-1][w];
                }
            }
        }
      visualizationHint: 展示二维 DP 表格的填充过程。
      mermaidCode: |
        graph TD
          Start["开始: 计算 dp(i, w)"] --> Check{"物品 i 是否放得下?"}
          Check -- "放不下 (w < wt[i])" --> NoTake["不放: dp(i-1, w)"]
          Check -- "能放下" --> Compare{"比较: 放 vs 不放"}
          Compare -->|不放| Option1["保持: dp(i-1, w)"]
          Compare -->|放| Option2["更新: dp(i-1, w-wt[i]) + val[i]"]
          Option1 --> Max[取最大值]
          Option2 --> Max
          Max --> Result["存入 dp(i, w)"]
    - name: 最长公共子序列
      coreIdea: 寻找两个序列共有的最长子序列。
      steps: |
        1. 定义 dp[i][j] 为 text1[0..i] 和 text2[0..j] 的 LCS 长度；
        2. 若 text1[i] == text2[j]，dp[i][j] = dp[i-1][j-1] + 1；
        3. 否则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。
      complexity: 时间复杂度 O(mn)，空间复杂度 O(mn)。
- title: 贪心算法
  category: 算法思想
  overview: 在对问题求解时，总是做出在当前看来是最好的选择。
  keywords:
    - 贪心
    - 局部最优
  difficultyLevel: 2
  algorithms:
    - name: 活动选择问题
      coreIdea: 每次选择结束时间最早且与已选活动不冲突的活动。
      steps: |
        1. 将活动按结束时间排序；
        2. 选择第一个活动；
        3. 依次检查后续活动，若开始时间 >= 上一个选中活动的结束时间，则选中。
      complexity: 排序 O(n log n) + 扫描 O(n)。
    - name: Huffman 编码
      coreIdea: 频率高的字符用短编码，频率低的用长编码，构建最优前缀码。
      steps: |
        1. 统计字符频率；
        2. 将每个字符看作单节点树，放入优先队列；
        3. 每次取出频率最小的两棵树合并，新树频率为两者之和，放回队列；
        4. 重复直到只剩一棵树。
      complexity: O(n log n)。
      mermaidCode: |
        graph TD
          A((58)) --> B((25))
          A --> C((33))
          B --> D(a: 10)
          B --> E(b: 15)
          C --> F(c: 12)
          C --> G((21))
          G --> H(d: 4)
          G --> I((17))
          I --> J(e: 8)
          I --> K(f: 9)
          style A fill:#f9f,stroke:#333
          style D fill:#ccf
          style E fill:#ccf
          style F fill:#ccf
          style H fill:#ccf
          style J fill:#ccf
          style K fill:#ccf
- title: 图算法
  category: 经典算法
  overview: 解决图结构相关问题的算法集合。
  keywords:
    - 图
    - 最短路径
    - 最小生成树
  difficultyLevel: 3
  algorithms:
    - name: Dijkstra 算法
      coreIdea: 从起点开始，每次选择当前距离最短的未访问节点，更新其邻居距离。
      steps: |
        1. 初始化 dist[]，起点为 0，其余无穷大；
        2. 使用优先队列维护未访问节点；
        3. 取出最小 dist 节点 u，松弛其所有邻居 v：if (dist[u] + w < dist[v]) dist[v] = dist[u] + w；
        4. 重复直到队列为空。
      complexity: O(E log V)。
      codeSnippet: |
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        while (!pq.isEmpty()) {
            Node u = pq.poll();
            if (visited[u.id]) continue;
            visited[u.id] = true;
            for (Edge e : adj[u.id]) {
                if (dist[u.id] + e.w < dist[e.to]) {
                    dist[e.to] = dist[u.id] + e.w;
                    pq.offer(new Node(e.to, dist[e.to]));
                }
            }
        }
      visualizationHint: 动态展示节点变色和距离更新过程。
    - name: Prim 算法
      coreIdea: 从任意节点开始，每次选择连接已选集合和未选集合的最小边。
      steps: |
        1. 维护 min_dist[] 表示节点到生成树的最小距离；
        2. 每次选 min_dist 最小的未访问节点加入生成树；
        3. 更新该节点邻居的 min_dist。
      complexity: O(E log V)。
- title: 搜索与排序
  category: 基础算法
  overview: 基础的查找和排序算法。
  keywords:
    - 二分
    - 排序
  difficultyLevel: 1
  algorithms:
    - name: 二分查找
      coreIdea: 在有序数组中，每次比较中间元素，将搜索范围缩小一半。
      steps: |
        1. 设定左右边界 left, right；
        2. mid = (left + right) / 2；
        3. 若 arr[mid] == target，返回；若 < target，left = mid + 1；否则 right = mid - 1。
      complexity: O(log n)。
      codeSnippet: |
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
      visualizationHint: 展示左右指针移动和搜索区间缩小的过程。
    - name: 快速排序
      coreIdea: 选定基准值，将小于基准的放左边，大于的放右边，递归排序。
      steps: |
        1. 选 pivot（如最后一个元素）；
        2. Partition 操作：将比 pivot 小的元素移到左侧；
        3. 递归处理左右两部分。
      complexity: 平均 O(n log n)，最坏 O(n^2)。
