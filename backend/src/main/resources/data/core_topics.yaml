- title: 分治策略
  category: 算法思想
  overview: 通过将问题拆分为子问题并递归求解，再合并结果以得到整体解。
  keywords:
    - 分治
    - 递归
    - 主定理
  difficultyLevel: 2
  algorithms:
    - name: 归并排序
      coreIdea: 将数组一分为二，递归排序，再在合并阶段保持有序。
      steps: |
        1. 将数组拆成两个子数组；
        2. 分别递归排序子数组；
        3. 双指针线性合并。
      complexity: 时间复杂度 O(n log n)，空间复杂度 O(n)。
      codeSnippet: |
        public void mergeSort(int[] arr, int left, int right) {
            if (left >= right) return;
            int mid = (left + right) >> 1;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
      visualizationHint: 使用分治树展示拆分和合并。
      mermaidCode: |
        graph TD
          A[8, 4, 5, 7, 1, 3, 6, 2] -->|Split| B[8, 4, 5, 7]
          A -->|Split| C[1, 3, 6, 2]
          B -->|Split| D[8, 4]
          B -->|Split| E[5, 7]
          C -->|Split| F[1, 3]
          C -->|Split| G[6, 2]
          D -->|Split| H[8]
          D -->|Split| I[4]
          H -->|Merge| J[4, 8]
          I -->|Merge| J
          E -->|Merge| K[5, 7]
          F -->|Merge| L[1, 3]
          G -->|Merge| M[2, 6]
          J -->|Merge| N[4, 5, 7, 8]
          K -->|Merge| N
          L -->|Merge| O[1, 2, 3, 6]
          M -->|Merge| O
          N -->|Merge| P[1, 2, 3, 4, 5, 6, 7, 8]
          style P fill:#f9f,stroke:#333,stroke-width:4px
    - name: 最近点对
      coreIdea: 先按坐标排序，按中线分成两部分，递归求解，再在跨区带内扫描。
      steps: |
        1. 按 x 轴排序；
        2. 递归求解左右最小距离；
        3. 在带宽 2d 条带中检查跨区点对。
      complexity: 平均与最坏时间复杂度皆为 O(n log n)。
      visualizationHint: 展示点集分割和中间条带的检查范围。
      mermaidCode: |
        graph TD
          Start[按 X 轴排序点集] --> Split{点数 <= 3?}
          Split -- 是 --> Base[暴力求解]
          Split -- 否 --> Divide[中线分割: Left, Right]
          Divide --> RecL[递归求解 Left -> d1]
          Divide --> RecR[递归求解 Right -> d2]
          RecL --> MinD[d = min(d1, d2)]
          RecR --> MinD
          MinD --> Strip[检查中线 2d 宽度的条带]
          Strip --> Final[返回 min(d, strip_min)]
- title: 动态规划
  category: 算法思想
  overview: 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
  keywords:
    - 动态规划
    - 状态转移
    - 最优子结构
  difficultyLevel: 3
  algorithms:
    - name: 0-1 背包问题
      coreIdea: 对于一组物品，每种物品都有自己的重量和价值，在限定的总重量内，选择物品使得总价值最高。
      steps: |
        1. 定义状态 dp[i][w] 为前 i 个物品放入容量为 w 的背包的最大价值；
        2. 状态转移：dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i])；
        3. 最终结果为 dp[N][W]。
      complexity: 时间复杂度 O(NW)，空间复杂度 O(NW) 或 O(W)。
      codeSnippet: |
        for (int i = 1; i <= N; i++) {
            for (int w = 1; w <= W; w++) {
                if (wt[i-1] <= w) {
                    dp[i][w] = Math.max(dp[i-1][w], 
                                      dp[i-1][w-wt[i-1]] + val[i-1]);
                } else {
                    dp[i][w] = dp[i-1][w];
                }
            }
        }
      visualizationHint: 展示二维 DP 表格的填充过程。
      mermaidCode: |
        graph TD
          Start["开始: 计算 dp(i, w)"] --> Check{"物品 i 是否放得下?"}
          Check -- "放不下 (w < wt[i])" --> NoTake["不放: dp(i-1, w)"]
          Check -- "能放下" --> Compare{"比较: 放 vs 不放"}
          Compare -->|不放| Option1["保持: dp(i-1, w)"]
          Compare -->|放| Option2["更新: dp(i-1, w-wt[i]) + val[i]"]
          Option1 --> Max[取最大值]
          Option2 --> Max
          Max --> Result["存入 dp(i, w)"]
    - name: 最长公共子序列
      coreIdea: 寻找两个序列共有的最长子序列。
      steps: |
        1. 定义 dp[i][j] 为 text1[0..i] 和 text2[0..j] 的 LCS 长度；
        2. 若 text1[i] == text2[j]，dp[i][j] = dp[i-1][j-1] + 1；
        3. 否则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。
      complexity: 时间复杂度 O(mn)，空间复杂度 O(mn)。
      visualizationHint: 展示字符匹配时的对角线转移。
      mermaidCode: |
        graph TD
          State["dp[i][j]"] --> Check{"text1[i] == text2[j] ?"}
          Check -- Yes --> Match["dp[i-1][j-1] + 1 (对角线)"]
          Check -- No --> Mismatch["max(dp[i-1][j], dp[i][j-1])"]
          Mismatch --> Up["dp[i-1][j] (上方)"]
          Mismatch --> Left["dp[i][j-1] (左方)"]
          style Match fill:#bfb
          style Mismatch fill:#fbb
- title: 贪心算法
  category: 算法思想
  overview: 在对问题求解时，总是做出在当前看来是最好的选择。
  keywords:
    - 贪心
    - 局部最优
  difficultyLevel: 2
  algorithms:
    - name: 活动选择问题
      coreIdea: 每次选择结束时间最早且与已选活动不冲突的活动。
      steps: |
        1. 将活动按结束时间排序；
        2. 选择第一个活动；
        3. 依次检查后续活动，若开始时间 >= 上一个选中活动的结束时间，则选中。
      complexity: 排序 O(n log n) + 扫描 O(n)。
      visualizationHint: 时间轴上展示活动区间，高亮选中的活动。
      mermaidCode: |
        gantt
          title 活动选择示例
          dateFormat HH:mm
          axisFormat %H:%M
          section 活动安排
          活动1 (选) :done, a1, 08:00, 09:00
          活动2 (冲突) :active, a2, 08:30, 10:00
          活动3 (选) :done, a3, 09:10, 11:00
          活动4 (冲突) :active, a4, 10:00, 11:30
          活动5 (选) :done, a5, 11:10, 12:00
    - name: Huffman 编码
      coreIdea: 频率高的字符用短编码，频率低的用长编码，构建最优前缀码。
      steps: |
        1. 统计字符频率；
        2. 将每个字符看作单节点树，放入优先队列；
        3. 每次取出频率最小的两棵树合并，新树频率为两者之和，放回队列；
        4. 重复直到只剩一棵树。
      complexity: O(n log n)。
      mermaidCode: |
        graph TD
          A((58)) --> B((25))
          A --> C((33))
          B --> D(a: 10)
          B --> E(b: 15)
          C --> F(c: 12)
          C --> G((21))
          G --> H(d: 4)
          G --> I((17))
          I --> J(e: 8)
          I --> K(f: 9)
          style A fill:#f9f,stroke:#333
          style D fill:#ccf
          style E fill:#ccf
          style F fill:#ccf
          style H fill:#ccf
          style J fill:#ccf
          style K fill:#ccf
- title: 图算法
  category: 经典算法
  overview: 解决图结构相关问题的算法集合。
  keywords:
    - 图
    - 最短路径
    - 最小生成树
  difficultyLevel: 3
  algorithms:
    - name: Dijkstra 算法
      coreIdea: 从起点开始，每次选择当前距离最短的未访问节点，更新其邻居距离。
      steps: |
        1. 初始化 dist[]，起点为 0，其余无穷大；
        2. 使用优先队列维护未访问节点；
        3. 取出最小 dist 节点 u，松弛其所有邻居 v：if (dist[u] + w < dist[v]) dist[v] = dist[u] + w；
        4. 重复直到队列为空。
      complexity: O(E log V)。
      codeSnippet: |
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        while (!pq.isEmpty()) {
            Node u = pq.poll();
            if (visited[u.id]) continue;
            visited[u.id] = true;
            for (Edge e : adj[u.id]) {
                if (dist[u.id] + e.w < dist[e.to]) {
                    dist[e.to] = dist[u.id] + e.w;
                    pq.offer(new Node(e.to, dist[e.to]));
                }
            }
        }
      visualizationHint: 动态展示节点变色和距离更新过程。
      mermaidCode: |
        graph LR
          S((Start: 0)) -->|5| A((A: 5))
          S -->|2| B((B: 2))
          B -->|1| A
          B -->|4| C((C: 6))
          A -->|3| D((D: 8))
          C -->|1| D
          style S fill:#f9f
          style B fill:#bfb
          style A fill:#bfb
          style C fill:#bfb
          style D fill:#dfd
    - name: Prim 算法
      coreIdea: 从任意节点开始，每次选择连接已选集合和未选集合的最小边。
      steps: |
        1. 维护 min_dist[] 表示节点到生成树的最小距离；
        2. 每次选 min_dist 最小的未访问节点加入生成树；
        3. 更新该节点邻居的 min_dist。
      complexity: O(E log V)。
      visualizationHint: 高亮显示逐步加入生成树的边。
      mermaidCode: |
        graph TD
          A((A)) ---|1| B((B))
          A ---|4| C((C))
          B ---|2| C
          B ---|5| D((D))
          C ---|1| D
          linkStyle 0 stroke:red,stroke-width:3px
          linkStyle 2 stroke:red,stroke-width:3px
          linkStyle 4 stroke:red,stroke-width:3px
          style A fill:#f9f
          style B fill:#f9f
          style C fill:#f9f
          style D fill:#f9f
    - name: 广度优先搜索 (BFS)
      coreIdea: 从起点开始，逐层向外扩展，先访问离起点最近的节点。
      steps: |
        1. 将起点入队，标记已访问；
        2. 队列非空时，出队节点 u；
        3. 遍历 u 的所有未访问邻居，入队并标记。
      complexity: O(V + E)。
      visualizationHint: 展示波纹扩散式的访问顺序。
      mermaidCode: |
        graph TD
          Level0((L0)) --> Level1_A((L1-A))
          Level0 --> Level1_B((L1-B))
          Level1_A --> Level2_C((L2-C))
          Level1_A --> Level2_D((L2-D))
          Level1_B --> Level2_E((L2-E))
          style Level0 fill:#f9f
          style Level1_A fill:#bfb
          style Level1_B fill:#bfb
          style Level2_C fill:#dfd
          style Level2_D fill:#dfd
          style Level2_E fill:#dfd
    - name: 深度优先搜索 (DFS)
      coreIdea: 从起点开始，尽可能深地搜索分支，直到无法继续再回溯。
      steps: |
        1. 访问节点 u，标记已访问；
        2. 递归访问 u 的每一个未访问邻居；
        3. 所有邻居访问完后回溯。
      complexity: O(V + E)。
      visualizationHint: 展示一条路走到黑再回头的过程。
      mermaidCode: |
        graph TD
          Root --> A
          A --> B
          B -->|Back| A
          A --> C
          C --> D
          D -->|Back| C
          C -->|Back| A
          A -->|Back| Root
          style Root fill:#f9f
          style A fill:#bfb
          style B fill:#dfd
          style C fill:#bfb
          style D fill:#dfd
    - name: 拓扑排序
      coreIdea: 对有向无环图 (DAG) 进行排序，使得对于每条边 u->v，u 都在 v 之前。
      steps: |
        1. 统计所有节点入度；
        2. 将入度为 0 的节点入队；
        3. 出队节点 u，将其邻居 v 入度减 1，若 v 入度变 0 则入队。
      complexity: O(V + E)。
      visualizationHint: 展示节点入度减少和移除过程。
      mermaidCode: |
        graph LR
          TaskA[任务A] --> TaskC[任务C]
          TaskB[任务B] --> TaskC
          TaskC --> TaskD[任务D]
          TaskD --> TaskE[任务E]
          style TaskA fill:#bfb
          style TaskB fill:#bfb
          style TaskC fill:#dfd
          style TaskD fill:#efd
          style TaskE fill:#ffd
- title: 搜索与排序
  category: 基础算法
  overview: 基础的查找和排序算法。
  keywords:
    - 二分
    - 排序
  difficultyLevel: 1
  algorithms:
    - name: 二分查找
      coreIdea: 在有序数组中，每次比较中间元素，将搜索范围缩小一半。
      steps: |
        1. 设定左右边界 left, right；
        2. mid = (left + right) / 2；
        3. 若 arr[mid] == target，返回；若 < target，left = mid + 1；否则 right = mid - 1。
      complexity: O(log n)。
      codeSnippet: |
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
      visualizationHint: 展示左右指针移动和搜索区间缩小的过程。
      mermaidCode: |
        graph TD
          Range["[0 ... 10]"] -->|Mid=5 < Target| Right["[6 ... 10]"]
          Right -->|Mid=8 > Target| Left["[6 ... 7]"]
          Left -->|Mid=6 == Target| Found((Found))
          style Found fill:#f9f,stroke:#333
    - name: 快速排序
      coreIdea: 选定基准值，将小于基准的放左边，大于的放右边，递归排序。
      steps: |
        1. 选 pivot（如最后一个元素）；
        2. Partition 操作：将比 pivot 小的元素移到左侧；
        3. 递归处理左右两部分。
      complexity: 平均 O(n log n)，最坏 O(n^2)。
      visualizationHint: 展示 Pivot 的位置确定和数组划分。
      mermaidCode: |
        graph TD
          Arr[3, 1, 4, 1, 5, 9, 2, 6] -->|Pivot=6| Part[3, 1, 4, 1, 5, 2 | 6 | 9]
          Part -->|Left| L[3, 1, 4, 1, 5, 2]
          Part -->|Right| R[9]
          L -->|Pivot=2| LPart[1, 1 | 2 | 3, 4, 5]
          LPart -->|Sorted| LS[1, 1, 2, 3, 4, 5]
          R -->|Sorted| RS[9]
          LS --> Final
          RS --> Final
          Final[1, 1, 2, 3, 4, 5, 6, 9]
          style Final fill:#f9f
- title: 字符串算法
  category: 经典算法
  overview: 处理字符串匹配和操作的算法。
  keywords:
    - KMP
    - 字符串匹配
  difficultyLevel: 3
  algorithms:
    - name: KMP 算法
      coreIdea: 利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。
      steps: |
        1. 构建 Next 数组（最长公共前后缀）；
        2. 匹配时若失配，根据 Next 数组移动模式串，而不是回退主串指针。
      complexity: O(M + N)。
      visualizationHint: 展示模式串在失配时的跳跃移动。
      mermaidCode: |
        graph TD
          Text[文本: A B A B A B C]
          Pattern[模式: A B A B C]
          Match1[匹配: A B A B ...] -->|C != A| Fail[失配!]
          Fail -->|查 Next 表| Shift[模式串右移 2 位]
          Shift --> Retry[新匹配: ... A B A B C]
          Retry --> Success((匹配成功))
          style Success fill:#f9f
